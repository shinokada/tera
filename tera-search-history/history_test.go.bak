package storage

import (
	"context"
	"os"
	"path/filepath"
	"testing"
)

func TestSearchHistoryStore(t *testing.T) {
	// Create temp directory
	tmpDir, err := os.MkdirTemp("", "tera-history-test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	store := NewStorage(tmpDir)
	ctx := context.Background()

	t.Run("NewSearchHistoryStore", func(t *testing.T) {
		history := NewSearchHistoryStore()
		if history.MaxSize != DefaultMaxHistorySize {
			t.Errorf("Expected MaxSize %d, got %d", DefaultMaxHistorySize, history.MaxSize)
		}
		if len(history.SearchItems) != 0 {
			t.Errorf("Expected empty SearchItems, got %d items", len(history.SearchItems))
		}
		if len(history.LuckyQueries) != 0 {
			t.Errorf("Expected empty LuckyQueries, got %d items", len(history.LuckyQueries))
		}
	})

	t.Run("AddSearchItem", func(t *testing.T) {
		// Add first item
		err := store.AddSearchItem(ctx, "tag", "jazz")
		if err != nil {
			t.Fatalf("Failed to add search item: %v", err)
		}

		// Load and verify
		history, err := store.LoadSearchHistory(ctx)
		if err != nil {
			t.Fatalf("Failed to load history: %v", err)
		}

		if len(history.SearchItems) != 1 {
			t.Fatalf("Expected 1 item, got %d", len(history.SearchItems))
		}

		if history.SearchItems[0].SearchType != "tag" {
			t.Errorf("Expected SearchType 'tag', got '%s'", history.SearchItems[0].SearchType)
		}
		if history.SearchItems[0].Query != "jazz" {
			t.Errorf("Expected Query 'jazz', got '%s'", history.SearchItems[0].Query)
		}
	})

	t.Run("AddSearchItem_Duplicate_MovesToTop", func(t *testing.T) {
		// Add more items
		store.AddSearchItem(ctx, "name", "BBC")
		store.AddSearchItem(ctx, "language", "english")
		
		// Add duplicate - should move to top
		store.AddSearchItem(ctx, "tag", "jazz")

		history, err := store.LoadSearchHistory(ctx)
		if err != nil {
			t.Fatalf("Failed to load history: %v", err)
		}

		// Should have 3 items (jazz moved to top)
		if len(history.SearchItems) != 3 {
			t.Fatalf("Expected 3 items, got %d", len(history.SearchItems))
		}

		// First item should be jazz
		if history.SearchItems[0].SearchType != "tag" || history.SearchItems[0].Query != "jazz" {
			t.Errorf("Expected first item to be 'tag:jazz', got '%s:%s'", 
				history.SearchItems[0].SearchType, history.SearchItems[0].Query)
		}
	})

	t.Run("AddSearchItem_MaxSize_Trim", func(t *testing.T) {
		// Clean slate
		store.ClearSearchHistory(ctx)
		
		// Set small max size
		store.UpdateHistorySize(ctx, 3)

		// Add 5 items
		store.AddSearchItem(ctx, "tag", "item1")
		store.AddSearchItem(ctx, "tag", "item2")
		store.AddSearchItem(ctx, "tag", "item3")
		store.AddSearchItem(ctx, "tag", "item4")
		store.AddSearchItem(ctx, "tag", "item5")

		history, err := store.LoadSearchHistory(ctx)
		if err != nil {
			t.Fatalf("Failed to load history: %v", err)
		}

		// Should only keep last 3
		if len(history.SearchItems) != 3 {
			t.Fatalf("Expected 3 items (trimmed), got %d", len(history.SearchItems))
		}

		// Should keep newest (item5, item4, item3)
		if history.SearchItems[0].Query != "item5" {
			t.Errorf("Expected newest item 'item5', got '%s'", history.SearchItems[0].Query)
		}
	})

	t.Run("AddLuckyQuery", func(t *testing.T) {
		// Clean slate
		store.ClearSearchHistory(ctx)
		
		err := store.AddLuckyQuery(ctx, "meditation")
		if err != nil {
			t.Fatalf("Failed to add lucky query: %v", err)
		}

		history, err := store.LoadSearchHistory(ctx)
		if err != nil {
			t.Fatalf("Failed to load history: %v", err)
		}

		if len(history.LuckyQueries) != 1 {
			t.Fatalf("Expected 1 lucky query, got %d", len(history.LuckyQueries))
		}

		if history.LuckyQueries[0] != "meditation" {
			t.Errorf("Expected query 'meditation', got '%s'", history.LuckyQueries[0])
		}
	})

	t.Run("AddLuckyQuery_Duplicate_MovesToTop", func(t *testing.T) {
		// Add more queries
		store.AddLuckyQuery(ctx, "jazz")
		store.AddLuckyQuery(ctx, "classical")
		
		// Add duplicate
		store.AddLuckyQuery(ctx, "meditation")

		history, err := store.LoadSearchHistory(ctx)
		if err != nil {
			t.Fatalf("Failed to load history: %v", err)
		}

		// Should have 3 queries
		if len(history.LuckyQueries) != 3 {
			t.Fatalf("Expected 3 queries, got %d", len(history.LuckyQueries))
		}

		// First should be meditation (moved to top)
		if history.LuckyQueries[0] != "meditation" {
			t.Errorf("Expected 'meditation' at top, got '%s'", history.LuckyQueries[0])
		}
	})

	t.Run("UpdateHistorySize_Increase", func(t *testing.T) {
		err := store.UpdateHistorySize(ctx, 20)
		if err != nil {
			t.Fatalf("Failed to update history size: %v", err)
		}

		history, err := store.LoadSearchHistory(ctx)
		if err != nil {
			t.Fatalf("Failed to load history: %v", err)
		}

		if history.MaxSize != 20 {
			t.Errorf("Expected MaxSize 20, got %d", history.MaxSize)
		}
	})

	t.Run("UpdateHistorySize_Decrease_TrimsItems", func(t *testing.T) {
		// Add some items
		store.ClearSearchHistory(ctx)
		store.UpdateHistorySize(ctx, 10)
		
		for i := 1; i <= 10; i++ {
			store.AddSearchItem(ctx, "tag", string(rune('a'+i-1)))
		}

		// Decrease size
		err := store.UpdateHistorySize(ctx, 5)
		if err != nil {
			t.Fatalf("Failed to update history size: %v", err)
		}

		history, err := store.LoadSearchHistory(ctx)
		if err != nil {
			t.Fatalf("Failed to load history: %v", err)
		}

		if len(history.SearchItems) != 5 {
			t.Errorf("Expected 5 items after trim, got %d", len(history.SearchItems))
		}
	})

	t.Run("ClearSearchHistory", func(t *testing.T) {
		// Add items
		store.AddSearchItem(ctx, "tag", "test1")
		store.AddLuckyQuery(ctx, "test2")

		// Clear
		err := store.ClearSearchHistory(ctx)
		if err != nil {
			t.Fatalf("Failed to clear history: %v", err)
		}

		history, err := store.LoadSearchHistory(ctx)
		if err != nil {
			t.Fatalf("Failed to load history: %v", err)
		}

		if len(history.SearchItems) != 0 {
			t.Errorf("Expected 0 search items after clear, got %d", len(history.SearchItems))
		}
		if len(history.LuckyQueries) != 0 {
			t.Errorf("Expected 0 lucky queries after clear, got %d", len(history.LuckyQueries))
		}

		// MaxSize should be preserved
		if history.MaxSize != 5 {
			t.Errorf("Expected MaxSize preserved (5), got %d", history.MaxSize)
		}
	})

	t.Run("LoadSearchHistory_FileNotExist", func(t *testing.T) {
		// Create new storage with non-existent path
		newTmpDir, _ := os.MkdirTemp("", "tera-new-test")
		defer os.RemoveAll(newTmpDir)
		
		newStore := NewStorage(newTmpDir)
		
		// Remove the search-history.json if it exists
		historyPath := filepath.Join(newTmpDir, "search-history.json")
		os.Remove(historyPath)

		history, err := newStore.LoadSearchHistory(ctx)
		if err != nil {
			t.Fatalf("Expected no error when file doesn't exist, got: %v", err)
		}

		if history.MaxSize != DefaultMaxHistorySize {
			t.Errorf("Expected default MaxSize %d, got %d", DefaultMaxHistorySize, history.MaxSize)
		}
	})
}
